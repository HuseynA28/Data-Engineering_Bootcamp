# SQL Query Structure

SQL queries typically follow this order:

1. **SELECT**: Choose columns.
2. **FROM**: Specify table(s).
3. **WHERE**: Filter rows.
4. **ORDER BY**: Sort results.
5. **LIMIT**: Restrict number of rows.

Understanding this flow ensures logical and efficient query construction.

---

## Selecting Data

### Select All Data
Retrieve all rows and columns from a table.

```sql
SELECT * FROM classicmodels.customers;
```

- `*`: All columns.

**Pros:**
- Simple and quick.
- Good for initial data exploration.

**Cons:**
- Inefficient for large tables.
- May expose sensitive data.

**Production Tip:** Use sparingly; prefer specifying columns for performance and security.

### Select Specific Columns
Retrieve only desired columns.

```sql
SELECT customerName, addressLine1
FROM classicmodels.customers;
```

**Pros:**
- Efficient data retrieval.
- Enhances security by limiting data exposure.
- Easier to read and maintain.

**Cons:**
- Requires updates if additional columns are needed later.

**Production Tip:** Best practice to specify needed columns for optimal performance and clarity.

### Select Unique Rows
Fetch distinct values to remove duplicates.

```sql
SELECT DISTINCT country
FROM classicmodels.customers;
```

**Pros:**
- Simplifies data analysis by eliminating duplicates.
- Cleaner result sets.

**Cons:**
- Can be resource-intensive on large datasets.

**Production Tip:** Use for analytical purposes, ensuring indexes are in place to improve performance.

---

## Filtering Data

### WHERE Clause
Filter rows based on conditions.

```sql
SELECT customerName
FROM classicmodels.customers
WHERE country = 'France' OR country = 'USA';
```

**Pros:**
- Precise data retrieval.
- Enhances query performance by reducing data load.

**Cons:**
- Complex conditions can reduce readability.

**Production Tip:** Essential for targeting specific data subsets; ensure conditions are optimized and indexed.

### Combining Conditions
Use logical operators to apply multiple filters.

```sql
SELECT customerName, creditLimit
FROM classicmodels.customers
WHERE country = 'France' AND creditLimit > 50000;
```

**Pros:**
- Allows detailed and specific data filtering.

**Cons:**
- Increased query complexity.

**Production Tip:** Combine conditions thoughtfully to maintain performance and accuracy.

---

## Sorting and Limiting Results

### ORDER BY Clause
Sort results by specified columns.

```sql
SELECT customerName, creditLimit
FROM classicmodels.customers
ORDER BY creditLimit DESC;
```

**Pros:**
- Organizes data for better readability.
- Essential for reports and dashboards.

**Cons:**
- Sorting large datasets can impact performance.

**Production Tip:** Use indexes on sorted columns to enhance performance.

### LIMIT Clause
Restrict the number of returned rows.

```sql
SELECT customerName, creditLimit
FROM classicmodels.customers
ORDER BY creditLimit DESC
LIMIT 3;
```

**Pros:**
- Improves performance by fetching only necessary rows.
- Useful for pagination and top-N queries.

**Cons:**
- May omit relevant data if not combined with proper sorting.

**Production Tip:** Always pair `LIMIT` with `ORDER BY` to ensure consistent results.

---

## Aggregation Functions

### COUNT Function
Count rows or non-null values in a column.

```sql
SELECT COUNT(*) FROM classicmodels.customers;
```

**Pros:**
- Quick summary of data volume.
- Optimized for performance with proper indexing.

**Cons:**
- Limited to quantitative insights.

**Production Tip:** Fundamental for reports and analytics to gauge data size and trends.

### Count Unique Values
Count distinct entries in a column.

```sql
SELECT COUNT(DISTINCT city) FROM classicmodels.customers;
```

**Pros:**
- Reveals data diversity.

**Cons:**
- More resource-intensive than simple counts.

**Production Tip:** Use for analytical insights, ensuring queries are optimized with indexes.

---

## Advanced Filtering

### BETWEEN and IN Operators

#### BETWEEN Operator
Filter values within a range (inclusive).

```sql
SELECT COUNT(*)
FROM classicmodels.orders
WHERE orderDate BETWEEN '2003-01-16' AND '2003-04-16';
```

**Pros:**
- Simplifies range queries.
- Enhances readability.

**Cons:**
- Inclusive of boundary values, which might be unintended.

**Production Tip:** Use precise ranges and consider time components for date fields.

#### IN Operator
Check if a value matches any in a list.

```sql
SELECT customerName, country
FROM classicmodels.customers
WHERE country IN ('Azerbaijan', 'France', 'USA');
```

**Pros:**
- Cleaner syntax compared to multiple OR conditions.
- Easily extendable for more values.

**Cons:**
- Large lists can reduce readability and performance.

**Production Tip:** Ideal for categorical filters; ensure the list size is manageable.

---

## Pattern Matching with LIKE

### LIKE Operator Basics
Search for patterns using wildcards.

| Wildcard | Description | Example |
|----------|------------|---------|
| `%`      | Any sequence of characters | `'A%'` → "Apple" |
| `_`      | Exactly one character | `'_at'` → "Cat" |

#### Example:

```sql
SELECT *
FROM classicmodels.employees
WHERE firstName LIKE 'A%';
```

**Pros:**
- Flexible pattern matching.
- Useful for search functionalities.

**Cons:**
- Can be slow on large datasets without indexing.
- Case sensitivity issues.

**Production Tip:** Optimize by using indexed columns and handling case sensitivity appropriately.

### Key Examples

- Starts with "A":
  ```sql
  WHERE firstName LIKE 'A%';
  ```
- Contains "nal":
  ```sql
  WHERE customerName LIKE '%nal%';
  ```
- Ends with "lan" + 1 character:
  ```sql
  WHERE customerName LIKE '%lan_';
  ```

### Case Sensitivity in MySQL

Default: Case-insensitive (`_ci` collations).

#### Case-Sensitive Searches:

Using BINARY:

```sql
WHERE BINARY firstName LIKE 'a%';
```

Using Functions:

```sql
WHERE LOWER(firstName) LIKE 'a%';
```

**Pros:**
- Precise control over matching.

**Cons:**
- May prevent index usage, impacting performance.

**Production Tip:** Balance case sensitivity needs with performance considerations.

### Advanced Pattern Matching

```sql
SELECT *
FROM classicmodels.payments
WHERE paymentDate LIKE '2004-05-%'    
  AND checkNumber LIKE 'N%';         
```

**Pros:**
- Enables complex data extraction.

**Cons:**
- Can significantly slow queries on large text fields.

**Production Tip:** Use sparingly and optimize with indexes where possible.

### NOT LIKE Operator
Exclude specific patterns.

```sql
SELECT *
FROM classicmodels.customers
WHERE customerName NOT LIKE '%nal%';
```

**Pros:**
- Refines data by excluding unwanted patterns.

**Cons:**
- Similar performance issues as `LIKE`.

**Production Tip:** Combine with other filters for precise data exclusion.
