# Dockerfile Example and Image Layers

## Consider the following Dockerfile:

```dockerfile
FROM python:latest
WORKDIR /myapp_folder
COPY requirements.txt myapp.py /myapp_folder/
RUN pip install -r requirements.txt
EXPOSE 8060
CMD ["uvicorn", "myapp:app", "--host", "0.0.0.0", "--port", "8060", "--reload"]
```

## What Are Image Layers?

### Each Instruction Is a Layer:
Every command (e.g., `FROM`, `WORKDIR`, `COPY`, `RUN`, etc.) in a Dockerfile creates a separate image layer. These layers are stacked on top of one another to form the final Docker image.

**Key point:** Once built, each layer is immutable (read-only). If you need to change any part of your image, you must rebuild that layer.

**Reference:** [Docker documentation on image layers](https://docs.docker.com/)

### Immutability and Reuse:
Because layers are unchangeable, Docker can reuse layers from previous builds if the instructions and their context (e.g., files copied or commands run) have not changed. This means that if you rebuild your image without modifying earlier steps, Docker uses a cached version of those layers—resulting in a very fast build.

## How Docker Build Caching Works

### Caching Mechanism:
When you run a build, Docker compares each step against its cache. If nothing has changed in a given step, Docker reuses the previously built layer rather than rebuilding it. For example, if you have not modified `requirements.txt` or `myapp.py`, the `COPY` command’s layer and the following `RUN` command’s layer will be reused.

### Cache Invalidation:
If you change one instruction (or any file used by that instruction), Docker invalidates that layer and all subsequent layers. This means even a small change in an early step causes Docker to rebuild all later steps.

**Practical Tip:** Arrange your Dockerfile so that steps that change less frequently (e.g., installing dependencies) come before those that change more often (e.g., copying your application code). This maximizes cache reuse and speeds up builds.

**Reference:** [Docker documentation on using the build cache](https://docs.docker.com/)

## Helpful Docker CLI Commands

When troubleshooting or managing your Docker images and containers, you can use various commands along with the `--help` flag to see available options:

### General Help:
Use the `--help` flag with any Docker command to display its usage information. For example:

```bash
docker ps --help
```
This will show you all options available with `docker ps`.

### Other Useful Commands:

- `-t`: Used with `docker build` to tag your image (e.g., `docker build -t myapp .`).
- `docker image inspect`: Provides detailed information about a Docker image.
- `docker rmi`: Removes one or more Docker images.
- `docker prune`: Cleans up unused Docker objects (containers, images, volumes, etc.).
- `docker ps` and `docker ps -a`: Lists running containers and all containers (including stopped ones), respectively.
- `docker logs <container>`: Displays the logs of a running (or stopped) container.

## Difference Between `docker run` and `docker start`

Understanding the distinction between these two commands is crucial:

### `docker run`:

**What it does:**
- Creates a new container from a specified image and immediately starts it.

**Use Case:**
- When you want to launch a container for the first time. It combines both container creation and startup.

**Example:**
```bash
docker run -d --name mycontainer python:latest
```


### `docker start`:

**What it does:**
- Starts an existing container that has been previously created (and is currently stopped).

**Use Case:**
- When you have already created a container (for example, using `docker create` or after stopping a container with `docker stop`) and now want to resume its operation.

**Example:**
```bash
docker start mycontainer
```

### Summary:

- Use `docker run` to **create and run** a new container.
- Use `docker start` to **resume** a container that has been stopped.
